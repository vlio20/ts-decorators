<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Utils-Decorators</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="./site/tailwind.css" rel="stylesheet">
  <link href="./site/highlight.css" rel="stylesheet">

  <style>
    *, ::after, ::before {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .ud-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 4rem;
      padding: 0 1.2rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      z-index: 10;
    }

    .ud-toolbar .ud-header {
      font-size: 1.5rem;
      color: #5F5F5F;
    }

    .ud-menu-btn {
      display: none;
      position: relative;
      top: 2px;
      border: 0;
      background: transparent;
      outline: 0;
    }

    @media (max-width: 599px) {
      .ud-menu-btn {
        display: block;
      }
    }

    .ud-page-container {
      flex: 1;
      display: flex;
    }

    .ud-sidenav {
      width: 14rem;
      height: calc(100vh - 4rem);
      background-color: white;
      border-right: 1px solid #F3F4F6;
      z-index: 5;
    }

    .ud-overlay {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      display: none;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }

    @media (max-width: 599px) {
      .ud-sidenav {
        position: fixed;
        transform: translateX(-100%);
      }

      .ud-nav-open .ud-sidenav {
        transform: translateX(0);
        transition: all 500ms;
      }

      .ud-nav-open .ud-overlay {
        display: block;
      }
    }

    .ud-sidenav li {
      height: 3.5rem;
      width: 100%;
      display: flex;
      align-items: center;
    }

    .ud-nav {
      border-bottom: 1px solid #F3F4F6;
    }

    .ud-nav:hover {
      background-color: #F3F4F6;
    }

    .ud-sidenav li > a,
    .ud-sidenav li > div {
      height: 100%;
      width: 100%;
      padding: 1rem;
    }

    .ud-sidenav li > a {
      padding-left: 1.5rem;
    }

    .ud-group {
      font-weight: bold;
    }

    .ud-main {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 4rem);
      overflow: auto;
    }

    .ud-section-title {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      background-color: #E5E7EB;
      color: #5F5F5F;
      font-size: 1.3rem;
      padding: 1.5rem;
    }

    .ud-section .ud-subtitle {
      font-weight: bold;
    }

    .ud-section-content {
      padding: 1.5rem;
    }

    .ud-description {
      margin-bottom: 1.5rem;
    }

    .ud-code-wrapper {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
      gap: 1.5rem;
    }

    @media (max-width: 599px) {
      .ud-code-wrapper {
        flex-direction: column;
      }
    }

    .ud-code-wrapper .ud-code-part {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 100%;
      overflow: auto;
    }

  </style>

</head>
<body>
<div class="ud-toolbar">
  <span class="ud-header">utils-decorators</span>
  <button class="ud-menu-btn" onclick="toggleMenu()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black" width="24px" height="24px">
      <path d="M0 0h24v24H0z" fill="none"/>
      <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
    </svg>
  </button>
</div>
<div class="ud-page-container">
  <div class="ud-sidenav">
    <ul>
      <li class="ud-group">
        <div>General</div>
      </li>

      <li class="ud-nav">
        <a href="#install">Installation</a>
      </li>

      <li class="ud-group">
        <div>Decorators</div>
      </li>

      <li class="ud-nav">
        <a href="#after">after</a>
      </li>

      <li class="ud-nav">
        <a href="#before">before</a>
      </li>

      <li class="ud-nav">
        <a href="#cancel-previous">cancel-previous</a>
      </li>

      <li class="ud-nav">
        <a href="#debounce">debounce</a>
      </li>

      <li class="ud-nav">
        <a href="#delay">delay</a>
      </li>

      <li class="ud-nav">
        <a href="#delegate">delegate</a>
      </li>

      <li class="ud-nav">
        <a href="#execTime">execTime</a>
      </li>

      <li class="ud-nav">
        <a href="#memoize">memoize</a>
      </li>
    </ul>
  </div>
  <div class="ud-main">
    <div class="ud-overlay" onclick="toggleMenu()"></div>
    <section class="ud-section">
      <div id="install"></div>
      <div class="ud-section-title">Installation</div>
      <div class="ud-section-content">
        <p class="ud-description">
          To install the lib via npm please follow the command bellow:
        </p>
        <pre class="ud-code">
    npm i utils-decorators</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="after"></div>
      <div class="ud-section-title">After</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause execution of the provided function method after the invocation
          of the decorated method.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface AfterConfig&lt;T = any, D = any&gt; {
    // the function (or the method name within the context) to invoke after the invocation of the decorated method
    func: keyof T | (args: ...any[]) => &lt;D&gt; ;

    // in case of a returned promise of the decorated method, should the after function wait for it to be resolved
    wait?: boolean;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Arguments to provided method:</div>
            <pre class="ud-code">
  interface AfterParams&lt;D = any&gt; {
    // the arguments that were provided to the decorated method
    args: any[];

    // the response data of the decorated method
    response: D;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { after } from 'utils-decorators';

  class Example1 {

    @after({
      func: 'after',
    })
    foo(x: number): number {
      return 42;
    }

    after(respData: AfterParams&lt;number&gt;): void {
      console.log(respData.args, respData.response);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { afterify } from 'utils-decorators';

  function foo = () => {
    console.log('original method called');
  }

  const fooWithAfter = afterify(foo, {
    func: (respData: AfterParams&lt;number&gt;) => {
        console.log(respData.args, respData.response);
    };
  });</pre>
          </div>
        </div>


        <div class="ud-subtitle">Decorator Example 2:</div>
        <pre class="ud-code">
  import { after } from 'utils-decorators';

  class Example2 {

    @after({
      func: (respData: AfterParams&lt;number&gt) => console.log(respData.args, respData.response),
      wait: true,
    })
    foo(x: number): Promise&lt;number&gt; {
      return this.numberProvider.getNumber(x);
    }
  }</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="before"></div>
      <div class="ud-section-title">Before</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause an execution of the provided function method before the
          invocation
          of the decorated method.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface BeforeConfig&lt;T = any, D = any&gt; {
    // the function (or the method name within the context) to invoke before the invocation of the decorated method
    func: keyof T | (args: ...any[]) => &lt;D&gt; ;

    // in case of a returned promise of the decorated method, should the before function wait for it to be resolved
    wait?: boolean;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { before } from 'utils-decorators';

  class Example1 {

    @before({
      func: 'before',
    })
    foo(x: number): number {
      return 42;
    }

    before(): void {
      console.log('this will be invoked before');
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { beforify } from 'utils-decorators';

  function foo = () => {
    console.log('original method called');
  }

  const fooWithBefore = beforify(foo, {
    func: () => {
        console.log('this will be invoked before');
    };
  });</pre>
          </div>

        </div>


        <div class="ud-subtitle">Decorator Example 2:</div>
        <pre class="ud-code">
  import { before } from 'utils-decorators';

  class Example2 {

    @after({
      func: () => console.log('this will be invoked before');,
      wait: true,
    })
    foo(x: number): Promise&lt;number&gt; {
      return this.numberProvider.getNumber(x);
    }
  }</pre>
      </div>
    </section>

    <section class="ud-section">
      <div id="cancel-previous"></div>
      <div class="ud-section-title">Cancel Previous</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Invocation of the decorated method will cause the a rejection of the previous invocation with an error of
          <i>CancelPromise</i> type.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { cancelPrevious } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @cancelPrevious()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { cancelPreviousify } from 'utils-decorators';

  const dataProvider = cancelPreviousify(() => {
    return fetch(...);
  }));</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="debounce"></div>
      <div class="ud-section-title">Debounce</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Causes a delay in the invocation of the decorated method by given time (in ms), if during the delay another
          invocation will happen, the delay will be restarted.
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
    // the time (in milliseconds) to wait before invoke
    delay: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { debounce } from 'utils-decorators';

  class Example1 {

    @debounce(1000)
    foo(x: number): number {
      return 42;
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { debouncify } from 'utils-decorators';

  function foo(): void {
    console.log('will be debounced')
  }

  const debouncedFoo = debouncify(foo, 1000);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="delay"></div>
      <div class="ud-section-title">Delay</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Causes a delay in the invocation of the decorated method by given time (in ms).
        </p>
        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // the time (in milliseconds) to wait before invoke
  delay: number;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { delay } from 'utils-decorators';

  class Example1 {

    @delay(1000)
    foo(x: number): number {
      return 42;
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { delayfy } from 'utils-decorators';

  function foo(): void {
    console.log('will be delayed')
  }

  const delayedFoo = delayfy(foo, 1000);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="delegate"></div>
      <div class="ud-section-title">Delegate</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          For a given input, if within the time period of the resolving of the promise of the first invocation the
          decorated method was invoked multiple times (with the same input) the response would be the promise that was
          generated by the first invocation. This way this decorator reduces the amount of calls to the implementation
          of the decorated method, for example accessing the database.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // an optional function (or a function name within the context) that maps the arguments to a specific key.
  // The default mapping function is JSON.stringify(args).
  keyResolver?: string | (...args: any[]) => string;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { delegate } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @delegate()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const delegatedFoo = delegatify(getData);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with custom mapper):</div>
            <pre class="ud-code">
  import { delegate } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @delegate((x, y) => `${x}_${y}`)
    getData(x, y): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData(x, y);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with custom mapper):</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const delegatedFoo = delegatify(getData, (x, y) => `${x}_${y}`);</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="execTime"></div>
      <div class="ud-section-title">Exec-Time</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Measures the time that takes for the decorated method to response.
          By default will log the result using <i>console.info()</i> but this can be changed by providing your own
          reporter
          function.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Arguments to the reporter function:</div>
            <pre class="ud-code">
  interface ExactTimeReportData = {
    args: any[];
    result: any;
    execTime: number;
  };</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  // an optional function (or a function name within the context) that receives <i>ExactTimeReportData</i>
  // (see details above) as an argument. If the decorated method returns a Promise,
  // the decorator will wait for it to be resolved/rejected.
  // The default report function is (data: ExactTimeReportData) => console.info(data.execTime)
  reporter?: string | (data: ExactTimeReportData) => any;
            </pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1:</div>
            <pre class="ud-code">
  import { execTime } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example1 {

    constructor(private readonly dataProvider: DataProvider) { }

    @execTime()
    getData(): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData();
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1:</div>
            <pre class="ud-code">
  import { execTimify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const measuredFoo = execTimify(getData);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with custom reporter):</div>
            <pre class="ud-code">
  import { execTime } from 'utils-decorators';
  import { DataProvider, DataDto } from './data-provider.service';

  class Example2 {

    constructor(private readonly dataProvider: DataProvider) { }

    @execTime((data: ExactTimeReportData) => {
        console.log(data.args, data.result, data.execTime);
    })
    getData(x, y): Promise&lt;DataDto&gt; {
      return this.dataProvider.getData(x, y);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with custom reporter):</div>
            <pre class="ud-code">
  import { delegatify } from 'utils-decorators';

  function getData(): Promise&lt;DataDto> {
    return dataProvider.getData();
  }

  const measuredFoo = execTimify(getData, (data: ExactTimeReportData) => {
    console.log(data.args, data.result, data.execTime);
  });</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="ud-section">
      <div id="memoize"></div>
      <div class="ud-section-title">Memoize</div>
      <div class="ud-section-content">
        <div class="ud-subtitle">Description:</div>
        <p class="ud-description">
          Memoizes the response that is being returned by the decorated method.
          Be default the key of the cached value will be the serialized <i>JSON.stringify</i> value of the provided
          arguments. You can supply your own key resolver.
          Also, you can provide your own cache, it has to implement the <i>Cache&lt;D&gt;</i> interface (see bellow), by
          default
          the decorator is using a simple <i>Map&lt;string, D&gt;</i>.
        </p>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Configuration:</div>
            <pre class="ud-code">
  interface MemoizeConfig&lt;T, D&gt; {
    // an optional cache object which should implement the Cache interface.
    // Internally the decorator is using Map&lt;string, D&gt;
    cache?: Cache&lt;D&gt;;

    // an optional function (or a function name within the context) that maps the arguments to a specific key.
    // The default mapping function is JSON.stringify(args).
    keyResolver?: string | (...args: any[]) => string;

    // An optional TTL (time to leave in milliseconds) for the entry to be removed from the cache.
    // If not provided the cache will be never cleared.
    expirationTimeMs?: number;
  }</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoize } from 'utils-decorators';

  class Example1 {

    @memoize()
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 1 (cache with no ttl):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  const memoizedFibo = memoizify(fibo);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoize, Cache } from 'utils-decorators';

  class Example3 {

    // a one hour ttl
    @memoize(1000 * 60 * 60)
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 2 (with a ttl only):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  // a one hour ttl
  const memoizedFibo = memoizeify(fibo, 1000 * 60 * 60);</pre>
          </div>
        </div>

        <div class="ud-code-wrapper">
          <div class="ud-code-part">
            <div class="ud-subtitle">Decorator Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoize, Cache } from 'utils-decorators';

  class CustomCache implements Cache&lt;number> {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  const customCache = new CustomCache();

  class Example2 {

    @memoize({
      cache: customCache
    })
    fibo(n: number): number; {
      if (n &lt; 2) return 1;

      return this.fibo(n - 1) + this.fibo(n - 2);
    }
  }</pre>
          </div>

          <div class="ud-code-part">
            <div class="ud-subtitle">Function Example 3 (with a custom cache):</div>
            <pre class="ud-code">
  import { memoizify } from 'utils-decorators';

  const customCache: Cache&lt;number&gt; = {
    set: (key: string, value: number) => {...};
    get: (key: string) => number | null => {...}
    delete: (key: string) => void => {...}
    has: (key: string) => boolean => {...}
  }

  function fibo(n: number): number {
    if (n &lt; 2) return 1;

     return fibo(n - 1) + fibo(n - 2);
  );

  const memoizedFibo = memoizeify(fibo, {
    cache: customCache,
  });</pre>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>
<script src="./site/highlight.js"></script>
<script>
  const body = document.querySelector('body');

  addEventListener('load', () => {
    document.querySelectorAll('pre.ud-code')
      .forEach(block => {
        hljs.highlightBlock(block);
      });
  });

  document.querySelectorAll('.ud-sidenav a').forEach(item => {
    item.addEventListener('click', event => {
      if (body.classList.contains('ud-nav-open')) {
        toggleMenu();
      }
    })
  })

  function toggleMenu() {
    if (body.classList.contains('ud-nav-open')) {
      body.classList.remove('ud-nav-open');
    } else {
      body.classList.add('ud-nav-open');
    }
  }
</script>
</body>
</html>
